---
title: "Take Home Exercise 02"
format:
  html:
    code-fold: true
    code-summary: "Show the code"

execute: 
  eval: true
  echo: true
  warning: false
date: "`r Sys.Date()`"
---

# 1.0 Setting the Scene

[Dengue Hemorrhagic Fever](https://www.cdc.gov/dengue/resources/denguedhf-information-for-health-care-practitioners_2009.pdf) (in short dengue fever) is one of the most widespread mosquito-borne diseases in the most tropical and subtropical regions. It is an acute disease caused by dengue virus infection which is transmitted by female Aedes aegypti and Aedes albopictus mosquitoes. In 2015, Taiwan had recorded the most severe dengue fever outbreak with more than 43,000 dengue cases and 228 deaths. Since then, the annual reported dengue fever cases were maintained at the level of not more than 200 cases. However, in 2023, Taiwan recorded 26703 dengue fever cases. Figure below reveals that more than 25,000 cases were reported at Tainan City.

# 2.0 Objective

-   if the distribution of dengue fever outbreak at Tainan City, Taiwan are independent from space and space and time.

-   If the outbreak is indeed spatial and spatio-temporal dependent, then, you would like to detect where are the clusters and outliers, and the emerging hot spot/cold spot areas.

# 3.0 The Task

The specific tasks of this take-home exercise are as follows:

-   Using appropriate function of **sf** and **tidyverse**, preparing the following geospatial data layer:

    -   a study area layer in sf polygon features. It must be at village level and confined to the D01, D02, D04, D06, D07, D08, D32 and D39 counties of Tainan City, Taiwan.

    -   a dengue fever layer within the study area in sf point features. The dengue fever cases should be confined to epidemiology week 31-50, 2023.

    -   a derived dengue fever layer in [spacetime s3 class of sfdep](https://sfdep.josiahparry.com/articles/spacetime-s3). It should contain, among many other useful information, a data field showing number of dengue fever cases by village and by epidemiology week.

-   Using the extracted data, perform global spatial autocorrelation analysis by using [sfdep methods](https://is415-gaa-tskam.netlify.app/in-class_ex/in-class_ex05/in-class_ex05-glsa).

-   Using the extracted data, perform local spatial autocorrelation analysis by using [sfdep methods](https://r4gdsa.netlify.app/chap10.html).

-   Using the extracted data, perform emerging hotspot analysis by using [sfdep methods](https://is415-gaa-tskam.netlify.app/in-class_ex/in-class_ex05/in-class_ex05-ehsa).

-   Describe the spatial patterns revealed by the analysis above.

# 4.0 The Data

Two data sets are provided, they are:

-   TAINAN_VILLAGE, a geospatial data of village boundary of Taiwan. It is in ESRI shapefile format. The data is in Taiwan Geographic Coordinate System. (Source: [Historical map data of the village boundary: TWD97 longitude and latitude](https://data.gov.tw/en/datasets/130549))

-   Dengue_Daily.csv, an aspatial data of reported dengue cases in Taiwan since 1998. (Source: [Dengue Daily Confirmed Cases Since 1998](https://data.cdc.gov.tw/en/dataset/dengue-daily-determined-cases-1998). Below are selected fields that are useful for this study:

    -   發病日: Onset date

    -   最小統計區中心點X: x-coordinate

    -   最小統計區中心點Y: y-coordinate

# 5.0 Importing and uploading R packages

```{r}
pacman::p_load(sf,tidyverse, sfdep, tmap, knitr, lubridate, plotly) 
```

# 6.0 Importing the data

## 6.1 Importing Geospatial Data

Importing TAINAN_VILLAGE.shp into R environment

```{r}
tainan_village <- st_read(dsn = "data/geospatial", layer = "TAINAN_VILLAGE")
```

Checking the coordinate system of tainan_village simple feature data frame using st_crs.

```{r}
st_crs(tainan_village)
```

Retrieving the geometry list-column.

```{r}
st_geometry(tainan_village)
```

## 6.2 Importing Aspatial Data

Importing csv data Dengue_Daily.csv into R environment

```{r}
dengue_daily <- read_csv("data/aspatial/Dengue_Daily.csv")
```

Reveal complete information of dengue_daily

Take note of 最小統計區中心點X and 最小統計區中心點Y columns. They are in character data type. Need to convert them to numeric later

```{r}
head(dengue_daily)
```

# 7.0 Data Preparation

## 7.1 Geospatial Data Wrangling

Extracting columns that are useful (COUNTYNAME, VILLNAME, VILLENG, TOWNID, geometry)

```{r}
tainan_village <- tainan_village %>% 
  select(COUNTYNAME, VILLNAME, VILLENG, TOWNID, geometry)
```

Filter TOWNID D01, D02, D04, D06, D07, D08, D32 and D39 from the tainan_village data

```{r}
filtered_tainan_village <- tainan_village %>% 
  filter(TOWNID %in% c("D01", "D02", "D04", "D06", "D07", "D08", "D32", "D39"))
```

Saving the filtered_tainan_village into RDS file

```{r}
write_rds(filtered_tainan_village, "data/rds/filtered_tainan_village.rds")
```

Plot the filtered_tainan_village

```{r}
tm_shape(filtered_tainan_village) +
  tm_polygons("TOWNID")
```

## 7.2 Aspatial Data Wrangling

Extracting columns (發病日, 居住縣市, 居住鄉鎮, 居住村里, 最小統計區中心點X, 最小統計區中心點Y) that are useful

```{r}
filtered_dengue_daily <- dengue_daily %>%
  select(發病日, 居住縣市, 居住鄉鎮, 居住村里, 最小統計區中心點X, 最小統計區中心點Y)
```

filter 居住縣市 to Tainan City

```{r}
filtered_dengue_daily <- filtered_dengue_daily %>% 
  filter(居住縣市 == "台南市")
```

Change 最小統計區中心點X, 最小統計區中心點Y datatype from chr to numeric

```{r}
filtered_dengue_daily <- filtered_dengue_daily %>% 
  mutate(最小統計區中心點X = as.numeric(最小統計區中心點X),
         最小統計區中心點Y = as.numeric(最小統計區中心點Y))
```

Filter 發病日 to only the year 2023

```{r}
filtered_dengue_daily2023 <- filtered_dengue_daily %>% 
  filter(year(發病日) == 2023)
```

Extract week 31 to 50 which is 2023-07-31 to 2023-12-17

```{r}
filtered_dengue_daily2023 <- filtered_dengue_daily %>% 
  filter(發病日 >= as.Date("2023-07-31") & 發病日 <= as.Date("2023-12-17"))
```

Add a new column called epic_week

```{r}
filtered_dengue_daily2023$epic_week <- week(filtered_dengue_daily2023$發病日)
```

Rename all the columns to English

```{r}
filtered_dengue_daily2023 <- filtered_dengue_daily2023 %>% 
  rename(onset_date = 發病日,
         county = 居住縣市,
         town = 居住鄉鎮,
         village = 居住村里,
         x_coordinate = 最小統計區中心點X,
         y_coordinate = 最小統計區中心點Y)
```

Remove None value from the village column

```{r}
filtered_dengue_daily2023 <- filtered_dengue_daily2023 %>% 
  filter(village !="None")
```

Group the dataset by village to get the number of dengue cases

```{r}
dengue_cases_by_village <- filtered_dengue_daily2023 %>%
  group_by(village, x_coordinate, y_coordinate) %>%
  summarise(dengue_cases = n())
```

Saving all files into RDS

```{r}
write_rds(filtered_dengue_daily2023, "data/rds/filtered_dengue_daily2023.rds")
write_rds(dengue_cases_by_village, "data/rds/dengue_cases_by_village.rds")
```

## 7.3 Perform join operation

Checking the coordinate system of dengue_cases_by_week_village. Need to set the coordinate system to 3824 before join operation

```{r}
st_crs(dengue_cases_by_village)
```

Checking NA value in x_coordinate and y_coordinate

```{r}
dengue_cases_by_village %>% 
  filter(is.na(x_coordinate) | is.na(y_coordinate))
```

Removing NA value in x_coordinate and y_coordinate

```{r}
dengue_cases_by_village <- dengue_cases_by_village[complete.cases(dengue_cases_by_village[, c("x_coordinate", "y_coordinate")]), ]
```

Transforming dengue_cases_by_village into simple feature data frame and set the coordinate system to 3824

```{r}
dengue_cases_by_village_sf <- st_as_sf(dengue_cases_by_village, coords = c("x_coordinate", "y_coordinate"), crs = 3824)
```

Checking the coordinate system of dengue_cases_by_village_sf. Confirming that the coordinate system is 3824

```{r}
st_crs(dengue_cases_by_village_sf)
```

The boundaries of filtered_tainan_village intersect with dengue_cases_by_village_sf dengue case locations.

```{r}
tainan_village_dengue_cases <- st_join(filtered_tainan_village, dengue_cases_by_village_sf, join = st_intersects)
```

checking NA value in tainan_village_dengue_cases

```{r}
tainan_village_dengue_cases %>% 
  filter(is.na(dengue_cases))
```

Removing NA value in tainan_village_dengue_cases

```{r}
tainan_village_dengue_cases <- tainan_village_dengue_cases[!is.na(tainan_village_dengue_cases$dengue_cases), ]
```

Summing the number of dengue cases by village

```{r}
total_dengue_cases_by_village <-  tainan_village_dengue_cases %>%
  group_by(village) %>%
  summarise(total_dengue_cases = sum(dengue_cases))
```

Saving file to RDS

```{r}
write_rds(total_dengue_cases_by_village, "data/rds/total_dengue_cases_by_village.rds")
```

Plotting a chropleth map on the distribution of dengue cases in Tainan City

```{r}
tmap_mode("plot")
tm_shape(total_dengue_cases_by_village) +
  tm_fill(col = "total_dengue_cases",
          style = "quantile",
          palette = "Blues",
          title = "Total Number of dengue Cases") +
  tm_layout(main.title = "Distribution of dengue cases in Tainan City",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45,
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type = "8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha = 0.2)
```

Based on the chropleth map, it is observed that the distribution of dengue cases in Tainan City is not uniform. The distribution is concentrated in the central.

# 8.0 Global Spatial Autocorrelation Analysis

## 8.1 Computing contiguity weights: Queen's method

```{r}
wm_q <- tainan_village_dengue_cases %>%
  mutate(nb = st_contiguity(geometry),
         wt = st_weights(nb, style = "W"),
         .before = 1)
```

```{r}
wm_q
```

## 8.2 Computing Global Moran's I Test

```{r}
moranI <- global_moran(wm_q$dengue_cases,
                       wm_q$nb,
                       wm_q$wt)
```

```{r}
glimpse(moranI)
```

This result indicates indicates spatial clustering of dengue cases in Tainan City. The value is 0.146 which is positive.

## 8.3 Performing Global Moran's I Test

```{r}
global_moran_test(wm_q$dengue_cases,
                       wm_q$nb,
                       wm_q$wt)
```

The p-value is close to 0 which means that the null hypothesis is rejected. This indicates that the distribution of dengue cases in Tainan City is not random. The alternative hypothesis is greater which shows that there is a spatial clustering of dengue cases in Tainan City.

## 8.4 Performing Global Moran's I permutation test

```{r}
set.seed(1234)
```

```{r}
global_moran_perm(wm_q$dengue_cases,
                       wm_q$nb,
                       wm_q$wt,
                  nsim = 99)
```

The results shows that the is a spatial autocorrelation of dengue cases in Tainan City. Which is consistent with the previous result.

# 9.0 Local Spatial Autocorrelation Analysis

## 9.1 Computing local Moran's I

```{r}
lisa <- wm_q %>% 
  mutate(local_moran = local_moran(
    dengue_cases, nb, wt, nsim = 99),
         .before = 1) %>%
  unnest(local_moran)
```

## 9.2 Visualizing local's Moran's I

```{r}
tmap_mode("plot")
tm_shape(lisa) +
  tm_fill("ii") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "local Moran's I of Dengue Cases",
            main.title.size = 0.8)
```

## 9.3 Visualizing p-value of local's Moran's I

```{r}
tmap_mode("plot")
tm_shape(lisa) +
  tm_fill("p_ii_sim") + 
  tm_borders(alpha = 0.5) +
   tm_layout(main.title = "p-value of local Moran's I",
            main.title.size = 0.8)
```

## 9.4 Visualizing local's Moran's I with significant p-value

```{r}
tmap_mode("plot")
map1 <- tm_shape(lisa) +
  tm_fill("ii") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "local Moran's I of Dengue Cases",
            main.title.size = 0.8)

map2 <- tm_shape(lisa) +
  tm_fill("p_ii",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of local Moran's I",
            main.title.size = 0.8)

tmap_arrange(map1, map2, ncol = 2)
```

## 9.5 Visualizing LISA Map

```{r}
lisa_sig <- lisa  %>%
  filter(p_ii < 0.05)
tmap_mode("plot")
tm_shape(lisa) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(lisa_sig) +
  tm_fill("mean") + 
  tm_borders(alpha = 0.4)
```

The map show that there are clustering of dengue cases in Tainan City.

-   The red area indicates that there are high-high clustering of dengue cases.

-   The green area indicates that there are low-low clustering of dengue cases.

-   The purple area indicate that there are low-high clustering of dengue cases which means that dengue cases are surrounded by areas with high dengue cases but they have lesser dengue cases which may indicate that the area is good in controlling dengue cases.

-   The yellow area indicates that there are high-low clustering of dengue cases but are surrounded by areas with higher dengue cases. They might need to take extra precaution to prevent dengue cases from increasing.

# 10.0 Hot Spot Cold Spot Area Analysis (HCSA)

## 10.1 Computing local Gi\* statistics

```{r}
wm_idw <- tainan_village_dengue_cases %>%
  mutate(nb = st_contiguity(geometry),
         wts = st_inverse_distance(nb, geometry,
                                   scale = 1,
                                   alpha = 1),
         .before = 1)
```

```{r}
HCSA <- wm_idw %>% 
  mutate(local_Gi = local_gstar_perm(
    dengue_cases, nb, wt, nsim = 99),
         .before = 1) %>%
  unnest(local_Gi)
HCSA
```

```{r}
tmap_mode("plot")
tm_shape(HCSA) +
  tm_fill("gi_star") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8))
```

From the map above, we can see that there is spatial clustering of dengue cases in Tainan City. The red area indicates that there are low gi\* values which means are cold spot which the green area indicates that there are high gi\* values which means are hot spot.

## 10.2 Visualising p-value of HCSA

```{r}
tmap_mode("plot")
tm_shape(HCSA) +
  tm_fill("p_sim") + 
  tm_borders(alpha = 0.5)
```

The map show that there most of the area are low p-value which means positive spatial autocorrelation. While some areas are dark brown.

## 10.3 Visualizing local HCSA

```{r}
tmap_mode("plot")
map1 <- tm_shape(HCSA) +
  tm_fill("gi_star") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "Gi* of Dengue Cases",
            main.title.size = 0.8)

map2 <- tm_shape(HCSA) +
  tm_fill("p_value",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of Gi*",
            main.title.size = 0.8)

tmap_arrange(map1, map2, ncol = 2)
```

Both maps show that area that are low gi\* value, their p value are also low.

## 10.4 Visualizing Hot Spot and Cold Spot Areas

```{r}
HCSA_sig <- HCSA  %>%
  filter(p_sim < 0.05)
tmap_mode("plot")
tm_shape(HCSA) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(HCSA_sig) +
  tm_fill("gi_star") + 
  tm_borders(alpha = 0.4)
```

The maps shows that there are quite a few hot spots (represented in dark green) around the center of the map. There are also a few cold spots (represented in dark red) which are not near the hot spots.

# 11.0 Emerging Hot Spot Analysis: sfdep methods

Importing RDS files

```{r}
filtered_tainan_village <- read_rds("data/rds/filtered_tainan_village.rds")
filtered_dengue_daily2023 <- read_rds("data/rds/filtered_dengue_daily2023.rds")
```

## 11.1 Preparing spacetime Data

Group dataset by epic_week, village

```{r}
dengue_cases_by_week_village <- filtered_dengue_daily2023 %>%
  group_by(epic_week, village, x_coordinate, y_coordinate) %>%
  summarise(dengue_cases = n())
```

Removing NA value in x_coordinate and y_coordinate

```{r}
dengue_cases_by_week_village <- dengue_cases_by_week_village[complete.cases(dengue_cases_by_week_village[, c("x_coordinate", "y_coordinate")]), ]
```

Transforming dengue_cases_by_week_village into simple feature data frame and set the coordinate system to 3824

```{r}
dengue_cases_by_week_village_sf <- st_as_sf(dengue_cases_by_week_village, coords = c("x_coordinate", "y_coordinate"), crs = 3824)
```

Checking the coordinate system of dengue_cases_by_week_village_sf

```{r}
st_crs(dengue_cases_by_week_village_sf)
```

The boundaries of filtered_tainan_village intersect with dengue_cases_by_week_village_sf dengue case locations.

```{r}
tainan_week_village_dengue_cases <- st_join(filtered_tainan_village, dengue_cases_by_week_village_sf, join = st_intersects)
```

Checking NA value in tainan_week_village_dengue_cases

```{r}
tainan_week_village_dengue_cases %>% 
  filter(is.na(dengue_cases))
```

Removing NA value in tainan_village_dengue_cases

```{r}
tainan_week_village_dengue_cases <- tainan_week_village_dengue_cases[!is.na(tainan_week_village_dengue_cases$dengue_cases), ]
```

Count unique number of villages

```{r}
unique_villages <-length(unique(tainan_week_village_dengue_cases$VILLNAME))
print(unique_villages)

```

Remove geometry column from total_cases_by_week_village

```{r}
tainan_week_village_dengue_cases_df <- as.data.frame(tainan_week_village_dengue_cases)

tainan_week_village_dengue_cases_df <- tainan_week_village_dengue_cases_df %>% select(-geometry)
```

Keep useful columns (VILLNAME, epic_week, dengue_cases)

```{r}
tainan_week_village_dengue_cases_df <- tainan_week_village_dengue_cases_df[, c("VILLNAME", "epic_week", "dengue_cases")]
```

Remove duplicate rows

```{r}
tainan_week_village_dengue_cases_df <- tainan_week_village_dengue_cases_df[!duplicated(tainan_week_village_dengue_cases_df[, c("VILLNAME", "epic_week")]), ]
```

```{r}
data <- crossing(VILLNAME = unique(tainan_week_village_dengue_cases_df$VILLNAME), epic_week = unique(tainan_week_village_dengue_cases_df$epic_week))
```

Merging the data and replace NA vlues with 0

```{r}
tainan_week_village_dengue_cases_df <- data %>%
  left_join(tainan_week_village_dengue_cases_df, by = c("VILLNAME", "epic_week")) %>%
  replace_na(list(dengue_cases = 0))
```

Checking the dimension

```{r}
print(dim(tainan_week_village_dengue_cases_df))
```

filter the tainan_week_village_dengue_cases_df to only the unique villages

```{r}
filtered_tainan_village_2 <- filtered_tainan_village %>%
  filter(VILLNAME %in% unique(tainan_week_village_dengue_cases_df$VILLNAME))
```

Check the number of unique villages in the filtered dataset

```{r}
print(length(unique(filtered_tainan_village_2$VILLNAME)))
```

Check the number of unique locations

```{r}
num_unique_locations_filtered_taiwan_village_2 <- nrow(unique(filtered_tainan_village))
print(num_unique_locations_filtered_taiwan_village_2)
```

Remove duplicate from filtered_tainan_village_2 and check the number of unique locations in filtered_tainan_village_2

```{r}
filtered_tainan_village_2 <- filtered_tainan_village_2[!duplicated(filtered_tainan_village_2$VILLNAME), ]

num_unique_locations_filtered_taiwan_village_2 <- nrow(unique(filtered_tainan_village_2))
print(num_unique_locations_filtered_taiwan_village_2)
```

```{r}
class(filtered_tainan_village_2)
class(tainan_week_village_dengue_cases_df)
```

Creating a Time Series Cube

```{r}
dengue_st <- spacetime(tainan_week_village_dengue_cases_df, filtered_tainan_village_2,
                      .loc_col = "VILLNAME",
                      .time_col = "epic_week")
```

Checking if the data is a spacetime object

```{r}
is_spacetime_cube(dengue_st)
```

## 11.2 Computing Gi\* statistics

Deriving the spatial weights

```{r}
dengue_nb <- dengue_st %>%
  activate("geometry") %>%
  mutate(nb = include_self(st_contiguity(geometry)),
         wt = st_inverse_distance(nb, geometry,
                                  scale = 1,
                                  alpha = 1),
         .before = 1) %>%
  set_nbs("nb") %>%
  set_wts("wt")
```

Checking if the data is a spacetime object

```{r}
is_spacetime(dengue_nb)
is_spacetime_cube(dengue_nb)
```

## 11.3 Computing local Gi\*

```{r}
gi_stars <- dengue_nb %>% 
  group_by(epic_week) %>% 
  mutate(gi_star = local_gstar_perm(
    dengue_cases, nb, wt)) %>% 
  unnest(gi_star)
```

## 11.4 Mann-Kendall Test

Use VILLANME = "一甲里" to test the Mann-Kendall Test

```{r}
cbg <- gi_stars %>% 
  ungroup() %>% 
  filter(VILLNAME == "一甲里") |> 
  select(VILLNAME, epic_week, gi_star)
```

Plotting the results

```{r}
ggplot(data = cbg, 
       aes(x = epic_week, 
           y = gi_star)) +
  geom_line() +
  theme_light()
```

Creating an interative plot by using ggplotly()

```{r}
p <- ggplot(data = cbg, 
       aes(x = epic_week, 
           y = gi_star)) +
  geom_line() +
  theme_light()

ggplotly(p)
```

```{r}
cbg %>%
  summarise(mk = list(
    unclass(
      Kendall::MannKendall(gi_star)))) %>% 
  tidyr::unnest_wider(mk)
```

Replicate this for each location using groupby()

```{r}
ehsa <- gi_stars %>%
  group_by(epic_week) %>%
  summarise(mk = list(
    unclass(
      Kendall::MannKendall(gi_star)))) %>%
  tidyr::unnest_wider(mk)
```

Arrange to show significant emerging hot/cold spots

```{r}
emerging <- ehsa %>% 
  arrange(sl, abs(tau)) %>% 
  slice(1:5)
```

## 11.5 Performing Emerging Hot Spot Analysis

```{r}
ehsa <- emerging_hotspot_analysis(
  x = dengue_st, 
  .var = "dengue_cases", 
  k = 1, 
  nsim = 99
)
```

Visualizing the distribution of EHSA classes

```{r}
ggplot(data = ehsa,
       aes(x = classification)) +
  geom_bar()
```

Visualising EHSA

```{r}
tainan_ehsa <- filtered_tainan_village %>%
  left_join(ehsa,
            by = join_by(VILLNAME == location))
```

Plot a catergoricaal choropleth map of EHSA

```{r}
ehsa_sig <- tainan_ehsa  %>%
  filter(p_value < 0.05)
tmap_mode("plot")
tm_shape(tainan_ehsa) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(ehsa_sig) +
  tm_fill("classification") + 
  tm_borders(alpha = 0.4)
```


# 12.0 Reflection

After finishing Take-Home Exercise 2, I realized that I need more practice in working with data. Be it data wrangling or data manipulation. I had to try different ways to solve errors and problems during the exercise which took out a lot of my time.

This Take-Home Exercise 2 had help me to understand the different types of analyses like finding clustering and outliers.

When attempting to do Take-Home Exercise 2, I had faced many errors, making it quite challenging to complete but it taught me a lot about what I need to work on to do better in Take-Home Exercise 3 and the final project.
