---
title: "Take-home Exercise 01"
format:
  html:
    code-fold: true
    code-summary: "Show the code"

execute: 
  eval: true
  echo: true
  warning: false
date: "`r Sys.Date()`"
---

# **1.0 Background**

Human mobility, the movement of human beings in space and time, reflects the spatial-temporal characteristics of human behavior. With the advancement Information and Communication Technologies (ICT) especially smart phone, a large volume of data related to human mobility have been collected. By using appropriate GIS analysis methods, these data are potentially useful in supporting smart city planning and management.

In Singapore, one of the important source of data related to human mobility is from Land Transport Authority (LTA) DataMall. Two data sets related to human mobility are provided by the portal, they are: Passenger Volume by Origin Destination Train Stations and Passenger Volume by Origin Destination Bus Stops. One of the limitation of these data sets is that their location are biased to either bus stops or MRT/LRT stations. In 2020, another very interesting human mobility data set called Grab Posisi was released by GRAB, one of the largest shared taxi operator in South-east Asia. There are two data sets been released and one of them is for Singapore.

# **2.0 Objectives**

Geospatial analytics hold tremendous potential to address complex problems facing society. In this study, you are tasked to apply appropriate spatial point patterns analysis methods to discover the geographical and spatio-temporal distribution of Grab hailing services locations in Singapore.

# **3.0 The Task**

The specific tasks of this take-home exercise are as follows:

-   Using appropriate function of **sf** and **tidyverse**, preparing the following geospatial data layer in sf tibble data.frames:

    -   Grab taxi location points either by origins or destinations.

    -   Road layer within Singapore excluding outer islands.

    -   Singapore boundary layer excluding outer islands

-   Using the extracted data, derive traditional Kernel Density Estimation layers.

-   Using the extracted data, derive either Network Kernel Density Estimation (NKDE) or Temporal Network Kernel Density Estimation (TNKDE)

-   Using appropriate **tmap** functions, display the kernel density layers on openstreetmap of Singapore.

-   Describe the spatial patterns revealed by the kernel density maps.

# **4.0 The Data**

## **Apstial data**

For the purpose of this assignment, Grab-Posisi of Singapore will be used.

## **Geospatial data**

-   Road data set from OpenStreetMap of Geofabrik download server. The Malaysia, Singapore, and Brunei coverage should be downloaded.

-   Master Plan 2019 Subzone Boundary (No Sea) from Data.gov.sg.

# **5.0. Importing Packages**

The R packages used in this project are:

-   **sf**, a relatively new R package specially designed to import, manage and process vector-based geospatial data in R.

-   **tidyverse** for performing data science tasks such as importing, wrangling and visualising data.

-   **spatstat**, which has a wide range of useful functions for point pattern analysis. In this hands-on exercise, it will be used to perform 1st- and 2nd-order spatial point patterns analysis and derive kernel density estimation (KDE) layer.

-   **raster** which reads, writes, manipulates, analyses and model of gridded spatial data (i.e. raster). In this hands-on exercise, it will be used to convert image output generate by spatstat into raster format.

-   **maptools** which provides a set of tools for manipulating geographic data. In this hands-on exercise, we mainly use it to convert *Spatial* objects into *ppp* format of **spatstat**.

-   **tmap** which provides functions for plotting cartographic quality static point patterns maps or interactive maps by using leaflet API.

-   **spNetwork**, which provides functions to perform Spatial Point Patterns Analysis such as kernel density estimation (KDE) and K-function on network. It also can be used to build spatial matrices (‘listw’ objects like in ‘spdep’ package) to conduct any kind of traditional spatial analysis with spatial weights based on reticular distances.

-   **rgdal**, which provides bindings to the ‘Geospatial’ Data Abstraction Library (GDAL) (\>= 1.11.4) and access to projection/transformation operations from the PROJ library. In this exercise, rgdal will be used to import geospatial data in R and store as sp objects.

-   **sp**, which provides classes and methods for dealing with spatial data in R. In this exercise, it will be used to manage SpatialPointsDataFrame and SpatiaLinesDataFrame, and for performing projection transformation.

```{r}
pacman::p_load(sp, sf, spNetwork, tmap, classInt, viridis, tidyverse, spatstat, sfdep, raster, maptools, arrow, lubridate)
```

# 6.0 Importing Data in R environment

## 6.1 Aspatial Data

### 6.1.1 Import GrabPosisi Data

```{r}
df <- read_parquet("data/Apstial/GrabPosisi/part-00000-8bbff892-97d2-4011-9961-703e38972569.c000.snappy.parquet")
```

## 6.2 Geospatial Data

### 6.2.1 Import Master Plan 2019 subzone Boundary (No Sea) Data

```{r}
mpsz_sf <- st_read(dsn= "data/Geospatial/MPSZ-2019", layer="MPSZ-2019")
```

### 6.2.2 Import Road data

```{r}
roads <- st_read(dsn = "data/Geospatial/malaysia-singapore-brunei-latest-free", layer = "gis_osm_roads_free_1")

```

# 7.0 Data Wrangling

Before we proceed with our analysis, we need to preprocess the data to the correct format and clean it.

## 7.1 Assign the correct CRS

### **7.1.1 mpsz_sf**

```{r}
mpsz3414 <- st_transform(mpsz_sf, crs = 3414)
st_crs(mpsz3414)
```

## 7.1.2 roads

```{r}
roads3414 <- st_transform(roads, crs = 3414)
st_crs(roads3414)
```

## 7.2 Convert data type of pingtimestamp from character to date-time

### 7.2.1 df

```{r}
df$pingtimestamp <- as_datetime(df$pingtimestamp)
```

## 7.2.2 Extract Grab taxi location points by origins

```{r}
origin_df <- df %>%
  group_by(trj_id) %>%
  arrange(desc(pingtimestamp)) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp, label=TRUE, abbr=TRUE), 
         start_hr = factor(hour(pingtimestamp)), 
         day = factor(mday(pingtimestamp)))
```

### 7.2.3 Creating a simple feature data frame from origin_df

```{r}
origin_sf <- st_as_sf(origin_df,
                      coords = c("rawlng", "rawlat"),
                      crs = 4326) %>%
  st_transform(crs = 3414)
```

## **7.3 Extract Singapore boundary layer excluding outer islands**

### 7.3.1 First, filter out the outer islands

```{r}
outer_island <- mpsz_sf[mpsz_sf$PLN_AREA_N == "SOUTHERN ISLANDS" | mpsz_sf$PLN_AREA_N == "NORTH-EASTERN ISLANDS" | mpsz_sf$PLN_AREA_N == "WESTERN ISLANDS",]
```

```{r}
plot(st_geometry(outer_island))
outer_island<- st_transform(outer_island, crs = 3414)
```

### 7.3.3 Filter out the outer island

```{r}
main_island <- st_difference(st_union(mpsz3414),st_union(outer_island))
```

```{r}
plot(st_geometry(main_island))
```

## 7.4 Filter out roads from roads3414 that have max speed value above 0.

```{r}
main_road <- roads3414 %>% filter(maxspeed > 0)
```

### 7.4.1 Find the roads that are only in Singapore excluding outer islands

```{r}
sg_roads <- st_intersection(main_road, main_island)
```

## 7.5 Road layer

```{r}
tm_shape(main_island) + tm_polygons() + tm_shape(sg_roads) + tm_lines(col="red", siz = 0.03)
```

## 7.6 Grab origin layer

```{r}
tm_shape(origin_sf) + tm_dots(siz = 0.03)
```

## 7.7 Converting sf data frames to sp's Spatial\* class

**spatstat** requires the analytical data in ***ppp*** object form. There is no direct way to convert a Spatial\* classes into ***ppp*** object. We need to convert the ***Spatial*** **classes**\* into ***Spatial*** object first.

```{r}
origin <- as_Spatial(origin_sf)
mpsz <- as_Spatial(mpsz3414)
main_island <- as_Spatial(main_island)
sg_roads <- as_Spatial(sg_roads)
```

## 7.8 Converting Spatial\* class into generic sp format

```{r}
origin_sp <- as(origin, "SpatialPoints")
main_island_sp <- as(main_island, "SpatialPolygons")
sg_roads_sp <- as(sg_roads, "SpatialLines")
origin_sp
```

## 7.9 Converting generic sp format into spatstat's ppp format

convert the spatial data into **spatstat**’s ***ppp*** object format.

```{r}
origin_ppp <- as(origin_sp, "ppp")
```

### 7.9.1 Plot origin_ppp for visualisation

```{r}
plot(origin_ppp)
```

```{r}
summary(origin_ppp)
```

## 7.10 Handling Duplicate Point

check the duplication in a ***ppp*** object

```{r}
any(duplicated(origin_ppp))
```

## 7.11 Creating owin object

When analysing spatial point patterns, it is a good practice to confine the analysis with a geographical area like Singapore boundary. In **spatstat**, an object called ***owin*** is specially designed to represent this polygonal region.

```{r}
main_island_owin <- as(main_island, "owin")
```

### 7.11.1 Display main_island_owin object

```{r}
plot(main_island_owin)
```

```{r}
summary(main_island_owin)
```

## 7.12 Combining point events object and owin object

Extract Grab origin point that are in main island in Singapore

```{r}
originSG_ppp = origin_ppp[main_island_owin]
```

```{r}
summary(originSG_ppp)
```

### 7.12.1 Plot originSg_ppp

```{r}
plot(originSG_ppp)
```

# 8.0 First-order Spatial Point Patterns Analysis

Deriving **kernel density estimation (KDE)** layer for visualising and exploring the intensity of point processes

## 8.1 Kernel Density Estimation

### 8.1.1 Compute kernel density estimation using automatic origin points in main land in Singapore

```{r}
kde_originSG_bw = density(originSG_ppp, 
                          sigma = bw.diggle, 
                          edge = TRUE, 
                          kernel="gaussian")
```

### 8.1.2 Display the kernel density derived

```{r}
plot(kde_originSG_bw)
```

### 8.1.3 Rescalling KDE Values

```{r}
originSG_ppp.km <-rescale(originSG_ppp, 1000, "km")
```

Re-run *density()* using the resale data set and plot the output kde map.

```{r}
kde_originSG.bw <- density(originSG_ppp.km, 
                           sigma=bw.diggle, 
                           edge=TRUE, 
                           kernel="gaussian")
```

### 8.1.4 Display the kernel density derived

```{r}
plot(kde_originSG.bw)
```

## 8.2 Converting KDE output into grid object Convert it so that it is suitable for mapping purposes

```{r}
gridded_kde_originSG_bw <- as.SpatialGridDataFrame.im(kde_originSG.bw)
spplot(gridded_kde_originSG_bw)
```

### 8.2.1 Converting gridded output into raster Convert the gridded kernal density objects into RasterLayer object

```{r}
kde_originSG_bw_raster <- raster(gridded_kde_originSG_bw)
```

Properties of kde_originSG_bw_raster RasterLayer

```{r}
kde_originSG_bw_raster
```

### 8.2.2 Assigning projection system in kde_originSG_bw_raster RasterLayer

```{r}
projection(kde_originSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_originSG_bw_raster
```

### 8.2.3 Visualising the output in tmap

```{r}
tm_shape(kde_originSG_bw_raster) + tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"),frame = FALSE)
```

## 8.3 Comparing Spatial Point Patterns using KDE Compare KDE of childcare at Ponggol, Tampines, Chua Chu Kang and Jurong West planning areas.

### 8.3.1 Extracting planning area boundary

```{r}
pg = mpsz[mpsz@data$PLN_AREA_N == "PUNGGOL",]
tm = mpsz[mpsz@data$PLN_AREA_N == "TAMPINES",]
ck = mpsz[mpsz@data$PLN_AREA_N == "CHOA CHU KANG",]
jw = mpsz[mpsz@data$PLN_AREA_N == "JURONG WEST",]
```

### 8.3.2 Plotting target planning areas

```{r}
plot(pg, main = "Ponggol")
plot(tm, main = "Tampines")
plot(ck, main = "Choa Chu Kang")
plot(jw, main = "Jurong West")
```

### 8.3.3 Converting the spatial point data frame into generic sp format

```{r}
pg_sp = as(pg, "SpatialPolygons")
tm_sp = as(tm, "SpatialPolygons")
ck_sp = as(ck, "SpatialPolygons")
jw_sp = as(jw, "SpatialPolygons")
```

### 8.3.4 Creating owin object

```{r}
pg_owin = as(pg_sp, "owin")
tm_owin = as(tm_sp, "owin")
ck_owin = as(ck_sp, "owin")
jw_owin = as(jw_sp, "owin")
```

### 8.3.5 Combining origin points and the study area Extract childcare that is within the specific region to do our analysis later on

```{r}
origin_pg_ppp = originSG_ppp[pg_owin]
origin_tm_ppp = originSG_ppp[tm_owin]
origin_ck_ppp = originSG_ppp[ck_owin]
origin_jw_ppp = originSG_ppp[jw_owin]
```

### Next, rescale() function is used to transform the unit of measurement from metre to kilometer.

```{r}
origin_pg_ppp.km = rescale(origin_pg_ppp, 1000, "km")
origin_tm_ppp.km = rescale(origin_tm_ppp, 1000, "km")
origin_ck_ppp.km = rescale(origin_ck_ppp, 1000, "km")
origin_jw_ppp.km = rescale(origin_jw_ppp, 1000, "km")
```

Plot these four study areas and the locations of the origin points

```{r}
plot(origin_pg_ppp.km, main="Punggol")
plot(origin_tm_ppp.km, main="Tampines")
plot(origin_ck_ppp.km, main="Choa Chu Kang")
plot(origin_jw_ppp.km, main="Jurong West")
```

### 8.3.6 Computing KDE

```{r}
plot(density(origin_pg_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(origin_tm_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tampines")
plot(density(origin_ck_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Choa Chu Kang")
plot(density(origin_jw_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Jurong West")
```

### 8.3.7 Storing KDE values

```{r}
kde_origin_pg.bw = density(origin_pg_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian")

kde_origin_tm.bw = density(origin_tm_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian")
             
kde_origin_ck.bw = density(origin_ck_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian")
             
kde_origin_jw.bw = density(origin_jw_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian")

```

## 8.4 Converting KDE output into grid object Convert it so that it is suitable for mapping purposes

```{r}
gridded_kde_origin_pg_bw <- as.SpatialGridDataFrame.im(kde_origin_pg.bw)
spplot(gridded_kde_origin_pg_bw)

gridded_kde_origin_tm_bw <- as.SpatialGridDataFrame.im(kde_origin_tm.bw)
spplot(gridded_kde_origin_tm_bw)

gridded_kde_origin_ck_bw <- as.SpatialGridDataFrame.im(kde_origin_ck.bw)
spplot(gridded_kde_origin_ck_bw)

gridded_kde_origin_jw_bw <- as.SpatialGridDataFrame.im(kde_origin_jw.bw)
spplot(gridded_kde_origin_jw_bw)

```

### 8.4.1 Converting gridded output into raster

```{r}
kde_origin_pg_bw_raster <- raster(gridded_kde_origin_pg_bw)
kde_origin_tm_bw_raster <- raster(gridded_kde_origin_tm_bw)
kde_origin_ck_bw_raster <- raster(gridded_kde_origin_ck_bw)
kde_origin_jw_bw_raster <- raster(gridded_kde_origin_jw_bw)
```

### 8.4.2 Assigning projection system in all raster layer

```{r}
projection(kde_origin_pg_bw_raster) <- CRS("+init=EPSG:3414")
projection(kde_origin_tm_bw_raster) <- CRS("+init=EPSG:3414")
projection(kde_origin_ck_bw_raster) <- CRS("+init=EPSG:3414")
projection(kde_origin_jw_bw_raster) <- CRS("+init=EPSG:3414")
```

### 8.4.3 Visualizing the output in tmap

```{r}
tm_shape(kde_origin_pg_bw_raster) + tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"),frame = FALSE)

tm_shape(kde_origin_tm_bw_raster) + tm_raster("v") + 
  tm_layout(legend.position = c("right", "bottom"),frame = FALSE)

tm_shape(kde_origin_ck_bw_raster) + tm_raster("v") + 
  tm_layout(legend.position = c("right", "bottom"),frame = FALSE)

tm_shape(kde_origin_jw_bw_raster) + tm_raster("v") + 
  tm_layout(legend.position = c("right", "bottom"),frame = FALSE)

```

# 9.0 Network Constrained KDE (NetKDE) Analysis Perform NetKDE analysis by using appropriate functions provided in spNetwork package.

## 9.1 Preparing data 9.1.1 road layer on 4 planning area

```{r}
pg <- mpsz3414[mpsz3414$PLN_AREA_N == "PUNGGOL",]
tm <- mpsz3414[mpsz3414$PLN_AREA_N == "TAMPINES",]
ck <- mpsz3414[mpsz3414$PLN_AREA_N == "CHOA CHU KANG",]
jw <- mpsz3414[mpsz3414$PLN_AREA_N == "JURONG WEST",]
```

```{r}
pg_roads <- st_intersection(roads3414,pg)
tm_roads <- st_intersection(roads3414,tm)
ck_roads <- st_intersection(roads3414,ck)
jw_roads <- st_intersection(roads3414,jw)
```

### 9.1.2 origin data on 4 planning area

```{r}
origin_pg <- st_intersection(origin_sf,pg)
origin_tm <- st_intersection(origin_sf,tm)
origin_ck <- st_intersection(origin_sf,ck)
origin_jw <- st_intersection(origin_sf,jw)
```

Drop redundant columns

```{r}
origin_pg <- origin_pg[-c(2:16)]
origin_tm <- origin_tm[-c(2:16)]
origin_ck <- origin_ck[-c(2:16)]
origin_jw <- origin_jw[-c(2:16)]
```

### 9.1.3 Preparing the lixels objects Before computing NetKDE, the SpatialLines object need to be cut into lixels with a specified minimal distance.

```{r}
pg_roads = st_cast(pg_roads, "LINESTRING")
tm_roads = st_cast(tm_roads, "LINESTRING")
ck_roads = st_cast(ck_roads, "LINESTRING")
jw_roads = st_cast(jw_roads, "LINESTRING")
```

```{r}
pg_lixels <- lixelize_lines(pg_roads, 
                         200, 
                         mindist = 100)
tm_lixels <- lixelize_lines(tm_roads,
                            200,
                            mindist = 100)
ck_lixels <- lixelize_lines(ck_roads,
                            200,
                            mindist = 100)
jw_lixels <- lixelize_lines(jw_roads,
                            200,
                            mindist = 100)

```

### 9.1.4 Gernerating line centre points Next, lines_center() of spNetwork will be used to generate a SpatialPointsDataFrame (i.e. samples) with line centre points

```{r}
pg_samples <- lines_center(pg_lixels)
tm_samples <- lines_center(tm_lixels)
ck_samples <- lines_center(ck_lixels)
jw_samples <- lines_center(jw_lixels)
```

### 9.1.5 Peforming NetKDE Puggol

```{r}
pg_densities <- nkde(pg_roads, 
                  events = origin_pg,
                  w = rep(1,nrow(origin_pg)),
                  samples = pg_samples,
                  kernel_name = "quartic",
                  bw = 300, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5,
                  sparse = TRUE,
                  verbose = FALSE)
```

**Tampines**

```{r}
tm_densities <- nkde(tm_roads, 
                  events = origin_tm,
                  w = rep(1,nrow(origin_tm)),
                  samples = tm_samples,
                  kernel_name = "quartic",
                  bw = 300, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5,
                  sparse = TRUE,
                  verbose = FALSE)

```

**Choa Chu Kang**

```{r}
ck_densities <- nkde(ck_roads, 
                  events = origin_ck,
                  w = rep(1,nrow(origin_ck)),
                  samples = ck_samples,
                  kernel_name = "quartic",
                  bw = 300, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5,
                  sparse = TRUE,
                  verbose = FALSE)

```

**Jurong West**

```{r}
jw_densities <- nkde(jw_roads, 
                  events = origin_jw,
                  w = rep(1,nrow(origin_jw)),
                  samples = jw_samples,
                  kernel_name = "quartic",
                  bw = 300, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5,
                  sparse = TRUE,
                  verbose = FALSE)

```

### 9.1.6 Visualising NetKDE Insert the computed density values (i.e. densities) into samples and lixels objects as density field.

```{r}
pg_samples$density <- pg_densities
tm_samples$density <- tm_densities
ck_samples$density <- ck_densities
jw_samples$density <- jw_densities

pg_lixels$density <- pg_densities
tm_lixels$density <- tm_densities
ck_lixels$density <- ck_densities
jw_lixels$density <- jw_densities
```

### 9.1.7 Rescalling density values

```{r}
pg_samples$density <- pg_samples$density*1000
tm_samples$density <- tm_samples$density*1000
ck_samples$density <- ck_samples$density*1000
jw_samples$density <- jw_samples$density*1000

pg_lixels$density <- pg_lixels$density*1000
tm_lixels$density <- tm_lixels$density*1000
ck_lixels$density <- ck_lixels$density*1000
jw_lixels$density <- jw_lixels$density*1000
```

**Punggol**

```{r}
tmap_mode('view')
tm_shape(pg_lixels)+
  tm_lines(col="density", lwd=5)+
  tm_shape(origin_pg)+
  tm_dots(alpha=0.5)
```

```{r}
tmap_mode('plot')
```

**Observation** : According to the Punggol map, it appears that Punggol Way has the highest density. This might be due to the limited convenience of public transportation in the area, leading residents to frequently utilize Grab services for transportation.

**Tampines**

```{r}
tmap_mode('view')
tm_shape(tm_lixels)+
  tm_lines(col="density", lwd=5)+
  tm_shape(origin_tm)+
  tm_dots(alpha=0.5)
```

```{r}
tmap_mode('plot')
```

**Observation**: According to the Tampines map, Changi Airport stands out as one of the areas with the highest density. This is logical, considering that individuals arriving in Singapore often rely on Grab services, especially since they may have luggage with them.

**Choa Chu Kang**

```{r}
tmap_mode('view')
tm_shape(ck_lixels)+
  tm_lines(col="density", lwd=5)+
  tm_shape(origin_ck)+
  tm_dots(alpha=0.5)
```

```{r}
tmap_mode('plot')
```

**Observation** : The Choa Chu Kang indicates that the central area od Choa Chu Kang, particularly in proximity to the MRT station, exhibits the highest density.

**Jurong West**

```{r}
tmap_mode('view')
tm_shape(jw_lixels)+
  tm_lines(col="density", lwd=5)+
  tm_shape(origin_jw)+
  tm_dots(alpha=0.5)
```

```{r}
tmap_mode('plot')
```

**Observation :** As per the Jurong West Map, the area with the highest density is located along Jurong West Avenue 2.
